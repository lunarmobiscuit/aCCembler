/*
 *  ROM for the mythical Apple ][4
 *
 *  aCCembler -l Apple2four.lst -o Apple2four.rom Apple2four.ac; cp Apple2four.rom ../../izapple2/resources 
 *
 */

const KBD			= $c000		// R last key pressed + 128
const KBDSTRB		= $c010		// RW keyboard strobe
const TAPEOUT		= $c020		// RW toggle caseette tape output
const SPKR			= $c030		// RW toggle speaker
const TXTCLR		= $c050		// RW display graphics
const TXTSET		= $c051		// RW display text
const MIXSET		= $c053		// RW display split screen
const TXTPAGE1		= $c054		// RW display page 1
const TXTPAGE2		= $c055		// RW display page 2
const LORES			= $c056		// RW display lo-res graphics
const SETAN0		= $c058		// RW annunciator 0 off
const SETAN1		= $c05a		// RW annunciator 1 off
const CLRAN2		= $c05d		// RW annunciator 2 on
const CLRAN3		= $c05f		// RW annunciator 3 on
const TAPEIN		= $c060		// R cassete tape input
const PADDL0		= $c064		// R analog input 0
const PTRIG			= $c070		// RW analog input reset
const LANGCLR		= $c082		// Disable "Language card" RAM
const LANGSET		= $c083		// Enable "Language card" RAM (requires two writes)
const CLRROM		= $cfff		// disable slot C8 ROM

const TOP_OF_STACK	= $feff		// Put the stack in the "Language card" RAM

const RSTVECTOR		= $fffc  	// Apple ][ 6502 reset vector
const PWREDUP		= $03f4  	// Apple ][ stores #$A5 to make RST a soft reboot

global TXTPTR 		= @$FE.a16	// $FE-$FF is the address of the current line of text
global TXTROW 		= @$3FF		// $3FF is the current row on the text screen
global TXTPOS 		= @$3FE		// $3FE is the current position (column) in the text screen
global TXTBUFFER 	= @$200		// $200-$27F holds the line of text being typed
global TXTBUFFER2 	= @$280		// $280-$2FF holds the previous line of text typed

const DISP_TEXT_1	= 0
const DISP_TEXT_2	= 1
const DISP_80COL_1	= 2
const DISP_80COL_2	= 3
const DISP_LORES_1	= 4
const DISP_LOWRS_2	= 5
const DISP_HIRES_1	= 6
const DISP_HIRES_2	= 7
const DISP_II4		= 8
global DISPMODE 	= @$3FD		// $3FC holds the current display mode (DISP_xxxx)

const N_COMMANDS	= 14		// The number of commands in CommandList


/*
 *  The code begins with a JMPs to the OS functions
 *  followed by a table of addresses for JSR ($aaaa) indirect calls
 */
sub Start() @$FF0000 {
	jmp Reset
}

/*
 *  RST vector points here
 */
sub Reset() @$FF0200 {
	cld
	sta LANGSET					; turn on ][+ "upper" 16K (write twice)
	sta LANGSET
	r16							; set the stack to be 16-bit wide
	sws
	ldx.w #TOP_OF_STACK			; initialize the stack to start at $FEFF
	txs.w

	lda TXTSET					; Start in TEXT mode
	lda TXTPAGE1				;  Page 1
	lda SETAN0					; AN0 = TTL hi
	lda SETAN1					; AN1 = TTL hi
	lda CLRAN2					; AN2 = TTL lo
	lda CLRAN3					; AN3 = TTL lo
	lda CLRROM					; turn off extension ROM
	bit KBDSTRB					; clear keyboard
	
	lda #2
	sta @TXTROW					; Start at TEXT row 2
	stz @TXTPOS					; Start at TEXT position 0
	
	ldx #0						; Clear the TEXT 2 page
	lda #DISP_TEXT_2
	sta @DISPMODE
	jsr ClearScreen
	stz @DISPMODE				; Start in TEXT mode, page 1
	ldx #0
	jsr ClearScreen				; Clear the TEXT 1 page

	jsr AppleII4				; draw the header
	; drop through to EchoKeys
}

/*
 *  Echo the keys as they are typed and store in @TXTBUFFER
 */
sub EchoKeys() {
	jsr ClearInputBuffers
	LOOP {
		jsr ScreenBase					; Set the @TEXTPTR based on @TXTROW
		lda @TXTPOS
		IF == {
			lda #':'H					; Draw the prompt
			jsr PrintChar
			jsr PrintCursor				; Draw the cursor
		}
		LOOP {
			bit KBD 					; check keyboard for next key
			IF - {
				BREAK
			}
		}
		lda KBD 						; get the key code from the keyboard and ack the read
		bit KBDSTRB
		IF == $8D {						; 13 = CR ($80 | $0D in high ASCII)
			jsr ClearCursor
			jsr NextLine
			jsr CurrentToPrevInputBuffer
			jsr CommandLine
			jsr ClearCurrentInputBuffer
			CONTINUE
		}
		IF == $88 {						; 8 = BS ($80 | $08 in high ASCII)
			if > 1 {
				jsr ClearCursor			; Erase the cursor
				lda #' 'H				; Erase the current character
				ldy @TXTPOS
				dey
				sta (@TXTPTR),y
				dey						; Delete the last character in the text buffer
				lda #0
				sta @TXTBUFFER,y
				dec @TXTPOS				; Decrement the text position
				jsr PrintCursor			; Draw the cursor
			}
			CONTINUE
		}
		IF == $95 {						; 21 = Right Arrow ($80 | $15 in high ASCII)
			if > 1 {
				jsr CompleteCommand
			}
			CONTINUE
		}
		IF == $8B {						; 11 = Up Arrow ($80 | $0B in high ASCII)
			jsr PrevToCurrentInputBuffer
			jsr InputBufferToTextScreen
			jsr PrintCursor				; Draw the cursor
			CONTINUE
		}
		IF == $9B {						; 27 = ESC ($80 | $1B in high ASCII)
			ldx @TXTROW					; Clear the current text buffer
			jsr ClearRow
			jsr ClearCurrentInputBuffer
			lda #0
			sta @TXTPOS					; reset to position 0

			lda @DISPMODE				; return to TEXT screen 1
			if (!=) {
				lda TXTPAGE1
				stz @DISPMODE
			}

			CONTINUE
		}
		IF > $9F {						; >31 = Not a control character ($80 | $1F in high ASCII)
			ldy @TXTPOS
			jsr PrintChar
			cpy #40 					; ignore if >= column 40
			IF < {
				and #$7F				; store (low) ASCII in TEXT buffer
				dey 					; Y-1 as TEXT position starts at 1, making space for the prompt
				sta @TXTBUFFER,y
				jsr PrintCursor
			}
		}
	}
}


/*
 *  Lookup and execute the typed command
 */
sub CommandLine() {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6

	lda #@TXTBUFFER						; %%0.1 <- the command text
	sta.t %%0.1

	lda #0								; %%0 <- the number of args (not including the command)
	sta %%0

	ldy #3								; Index to the next %%0.parameter
	ldx #0
	LOOP {
		lda @TXTBUFFER,x				; Look for a space
		IF (== 0) {
			BREAK
		}
		cmp #' '
		IF (==) {
			LOOP {
				lda @TXTBUFFER,x		; Skip over extra spaces
				IF (== 0) {
					BREAK
				}
				cmp #' '
				IF (==) {
					lda #0
					sta @TXTBUFFER,x
					inx
				}
				BREAK
			}

			lda #@TXTBUFFER
			clc
			adx.w
			sta.t.a16 %%0.1,y			; CMD is %%0.1, ARG0 is %%0.4, ARG1 is %00.7, ... %%0.10, etc.
			iny
			iny
			iny
			inc %%0
			inx
			BREAK
		}
		inx								; DO WHILE X < 127 (leave one zero in the TEXT buffer)
		cpx #127
		if (>=) {
			BREAK
		}
	}

	LOOP {
		lda @TXTBUFFER,x				; Look for a comma between args
		IF (== 0) {
			BREAK
		}
		cmp #','
		IF (==) {
			lda #0
			sta @TXTBUFFER,x
			inx

			LOOP {
				lda @TXTBUFFER,x			; Skip over extra spaces
				IF (== 0) {
					BREAK
				}
				cmp #' '
				IF (==) {
					lda #0
					sta @TXTBUFFER,x
					inx
				}
				BREAK
			}

			lda #@TXTBUFFER
			clc
			adx.w
			sta.t.a16 %%0.1,y			; CMD is %%0.1, ARG0 is %%0.4, ARG1 is %00.7, ... %%0.10, etc.
			iny
			iny
			iny
			inc %%0
		}
		inx								; DO WHILE X < 127 (leave one zero in the TEXT buffer)
		cpx #127
		if (>=) {
			BREAK
		}
	}

	lda.t %%0.1							; strA for CompareText
	sta.t %%7
	FOR @I = 0 TO N_COMMANDS-1 {
		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t %%7.3
		jsr CompareText
		IF - {
			ldx @I6
	  		lda.t CommandList+3,X		; CommandList[X].func
	  		sta.t %R0
			jsr.a24 (%R0)
			RETURN
		}
	}
	RETURN
}

/*
 *  Try and complete the command
 */
sub CompleteCommand() {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6

	lda #@TXTBUFFER						; %%7 <- TEXT buffer
	sta.t %%7
	FOR @I = 0 TO N_COMMANDS-1 {
		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t %%7.3
		jsr CompareStartOfText
		IF - {
			ldx @I6
	  		lda.t CommandList,X			; %%0.1 <- CommandList[X].string
	  		sta.t %%7
			lda #@TXTBUFFER				; %%7.3 <- TEXT buffer
			sta.t %%7.3
			jsr CopyString
			lda.w @TXTPTR				; @TXTPTR <- Current line on TEXT screen
			inc.w						;  +1 for the cursor
			sta.t %%7.3
			jsr CopyStringHigh
			iny
			sty @TXTPOS					; CopyString leaves the length of the string in Y
			jsr PrintCursor
			RETURN
		}
	}

	RETURN
}

#include "2four/util.ac"
#include "2four/disk4.ac"
#include "2four/commands.ac"
#include "2four/data.ac"

/*
 *  The 6502 vectors
 */
data Vectors @$FFFFF7 u24 {
	$000000 	; NMI
	$FF0000 	; RESET
	$000000 	; IRQ
}
