/*
 *  ROM for the mythical Apple ][4
 *
 *  Shell-level commands
 *
 */

const N_LINES_PER_PAGE = 22

/*
 *  '?' - List the commands
 */
sub DoHelp {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6
	var COL	= @$06						; column 0/12/24

	jsr NextLine
	
	lda.t #CommandListStr
	sta.t @ARGT0
	jsr PrintString
	jsr NextLine

	@I = 1
	@COL = 0
	DO {
		jsr PrintSpace

		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t @ARGT0
		jsr PrintString

		lda @COL
		IF ==  {
			@COL = 1
			@TXTPOS = 12
		}
		ELSE {
			IF == 1 {
				@COL = 2
				@TXTPOS = 24
			}
			IF == 2 {
				@COL = 0
				jsr NextLine		
			}
		}

		inc @I
		lda @I
	}
	WHILE (< N_COMMANDS)
	
	jsr NextLine		
	jsr NextLine		

	RETURN
}


/*
 *  'ascii' - Show all the ASCII characters
 */
sub DoAscii {
	var I	= @$04						; loop variable
	var J	= @$05						; I * 6
	var C	= @$03						; (@I << 4) + J

	jsr NextLine
	
	lda.t #ASCIIHeaderStr
	sta.t @ARGT0
	jsr PrintString
	jsr NextLine

	lda.t #ASCIIDashesStr
	sta.t @ARGT0
	jsr PrintString
	jsr NextLine

	FOR @I = 0 TO 15 {
		lda @I							; Print 0-F row value
		jsr PrintHexDigit
		lda #'-'H
		jsr PrintChar

		FOR @J = 0 TO 15 {
			lda @C						; A = (@I << 4) + J
			jsr PrintChar
			inc @C
		}

		jsr NextLine
	}

	lda.t #ASCIIDashesStr
	sta.t @ARGT0
	jsr PrintString
	jsr NextLine

	RETURN
}


/*
 *  'catalog' - Show the list of files on the harddisk or floppy
 */
sub DoCatalog {
	jsr NextLine
	
	lda.t #CatalogHeaderStr
	sta.t @ARGT0
	jsr PrintString
	jsr Disk4Name
	jsr PrintString
	jsr NextLine

	jsr Disk4CatalogStart
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	jsr NextLine

	LOOP {
		jsr Disk4CatalogNext
		if (!=) {
			BREAK
		}

		lda #2						; Print type (3 chars)
		sta @TXTPOS		
		lda DISK4_RAM
		jsr PrintChar
		lda DISK4_RAM+1
		jsr PrintChar
		lda DISK4_RAM+2
		jsr PrintChar

		lda #6						; Print size (3 numeric chars)
		sta @TXTPOS		
		lda DISK4_RAM+3
		jsr PrintChar
		lda DISK4_RAM+4
		jsr PrintChar
		lda DISK4_RAM+5
		jsr PrintChar

		lda #10						; Print filename
		sta @TXTPOS		
		jsr PrintString
		
		jsr NextLine
	}
	jsr NextLine

	RETURN
}


/*
 *  'clear'
 */
sub DoClear {
	lda @DISPMODE
	if (==) {
		ldx #2
		jsr ClearScreen
		lda #2
		sta @TXTROW						; Start at row 2
		lda #0
		sta @TXTPOS						; Start at position 0
		RETURN
	}
	if (== DISP_TEXT_2) {
		ldx #0
		jsr ClearScreen
	}
	RETURN
}


/*
 *  'echo'
 */
sub DoEcho {
	lda #$200
	sta.t @ARGT0
	jsr PrintString
	jsr NextLine
	RETURN
}


/*
 *  'load' filename address
 *
 */
sub DoLoad {
	jsr NextLine

	lda.t @ARGN							; must specify a filename
	if (< 1) {
		lda.t #NoFilenameErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}
	lda.t @ARGN							; and an address
	if (< 2) {
		lda.t #NoAddressErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}

	lda.t @ARGT2						; move the address to @ARGT0
	sta.t @ARGT0
	jsr ParseNumber
	sta.t @ARGT2

	lda.t @ARGT1						; move the filename to @ARGT0
	sta.t @ARGT0
	if (==) {							; filename is missing
		lda #NoFilenameErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}

	var FN = %R9.b
	jsr Disk4Open
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN

	lda #$6000							; Use $6000 as a read buffer // @@@ TBD
	sta.t @ARGT0

	var IDX = %R3.t						; index of total bytes read
	var ACTUAL = %R6.t					; actual bytes read per Disk4Read

	stz.t @IDX
	LOOP {
		jsr Disk4Read
		if (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t DISK4_RET0				; Or check for zero byes (to be safe)
		if (==) {
			BREAK
		}
		sta.t @ACTUAL

		ldx #0
		LOOP {
			txa.t
			tay.t
			lda.a24 (@ARGT0),Y
			ldy.t @IDX
			sta.a24 (@ARGT2),Y
			inc.t @IDX
			inx.t
			cpx.w @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

	lda @FN
	jsr Disk4Close

	lda.t #LoadedStr
	sta.t @ARGT0
	jsr PrintString

	lda.t @ACTUAL
	jsr PrintHex24

	lda.t #LoadedBytesToStr
	sta.t @ARGT0
	jsr PrintString

	lda.t @ARGT2
	jsr PrintHex24

	jsr NextLine
	jsr NextLine

	RETURN
}


/*
 *  'view'
 */
sub DoView {
	jsr NextLine

	lda.t @ARGN							; must specify a filename
	if (< 1) {
		lda.t #NoFilenameErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}

	lda.t @ARGT1						; move the filename to @ARGT0
	sta.t @ARGT0
	if (==) {							; filename is missing
		lda #NoFilenameErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}

	var FN = %R11.b
	jsr Disk4Open
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN

	lda #$6000							; Use $6000 as a read buffer // @@@ TBD
	sta.t @ARGT0

	var IDX 		= %R3.t				; index into the read buffer
	var ACTUAL 		= %R6.t				; actual bytes read per Disk4Read
	var LINENUM 	= %R9.b				; line count
	var STOP 		= %R10.b			; stop scrolling

	stz @LINENUM
	stz @STOP
	LOOP {
		jsr Disk4Read
		if (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t DISK4_RET0				; Or check for zero byes (to be safe)
		if (==) {
			BREAK
		}
		sta.t @ACTUAL

		stz.t @IDX
		LOOP {
			ldy.t @IDX
			lda.a24 (@ARGT0),Y
			IF (== 10) {
				jsr View_Paginate
			}
			IF (>= 32) {				; Only visible characters
				ldy @TXTPOS
				ora #$80				; High ASCII
				sta (@TXTPTR),y
				inc @TXTPOS
				cpy #39					; The next pos is off the screen, so newline
				IF (>=) {
					jsr View_Paginate
					if (!=) {

					}
					ldy.t @IDX
					lda.a24 (@ARGT0),Y
				}
			}
			inc.t @IDX
			lda.t @IDX
			cmp.t @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

	lda @FN
	jsr Disk4Close

	lda @LINENUM						; Pause every N_LINES_PER_PAGE lines (not 24, as there is a header)
	if (== N_LINES_PER_PAGE-1) {
		jsr GetChar
	}
	jsr NextLine

	RETURN
}
sub View_Paginate {
	var LINENUM 	= %R9.b		; line count
	var STOP 		= %R11.b	; stop scrolling

	inc @LINENUM
	lda @LINENUM				; Pause every N_LINES_PER_PAGE lines (not 24, as there is a header)
	if (== N_LINES_PER_PAGE) {
		jsr GetChar
		if (== $83) {				; Stop scrolling on ^C
			lda #1
			sta @STOP
		}
		if (== $9B) {			; Stop scrolling on ESC
			lda #1
			sta @STOP
		}
		stz @LINENUM
	}

	jsr NextLine
	stz @TXTPOS
	ldy @TXTPOS
	
	RETURN @STOP
}


/*
 *  'peek' addr[,addr] or addr[,+length]
 */
sub DoPeek {
	var START_ADDR 	= @TOP_OF_STACK+4.t		; starting address
	var END_ADDR 	= @TOP_OF_STACK+7.t		; ending address
	var LINENUM 	= %R9.b					; line count
	var STOP 		= %R10.b				; stop scrolling
	var CUR_ADDR 	= %R11.t				; current address

	lda.t @ARGN								; must specify a filename
	if (< 1) {
		lda.t #NoAddressErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}
	lda.t @ARGT1							; move the address to @ARGT0
	sta.t @ARGT0
	jsr ParseNumber
	and.t #$FFFFF0							; round down to multiple of 16
	sta.t @START_ADDR

	lda.t @ARGN								; and an address
	if (>= 2) {
		lda (@ARGT2)
		cmp #'+'
		if (==) {							; +length 
			lda.t @ARGT2
			sta.t @ARGT0
			inc.t @ARGT0					; move the address+1 to @ARGT0
			jsr ParseNumber
			tax.t
			lda.t @START_ADDR				; @END = @START + length
			adx.t
			sta.t @END_ADDR
		}
		ELSE {
			lda.t @ARGT2					; move the address to @ARGT0
			sta.t @ARGT0
			jsr ParseNumber
			sta.t @END_ADDR
		}
	}
	ELSE {
		lda.t @START_ADDR
		clc
		adc.t #$40
		sta.t @END_ADDR
	}

	jsr NextLine

	stz @LINENUM
	stz @STOP
	lda.t @START_ADDR
	sta.t @CUR_ADDR
	LOOP {
		jsr Draw_Peek_Line
		jsr Loop_Paginate

		lda.t @CUR_ADDR
		clc
		adc.t #8
		sta.t @CUR_ADDR
		cmp.t @END_ADDR
		if (>=) {
			BREAK
		}
	}
	RETURN
}
sub Draw_Peek_Line {
	var ADDR = %R11.t				; starting address

	lda #'$'H						; $addr- xx xx xx xx xx xx xx xx ........
	jsr PrintChar
	lda.t @ADDR
	jsr PrintHex24
	lda #'-'H
	jsr PrintChar

	FOR X = 0 to 7 {
		txa
		tay
		lda (@ADDR),Y
		jsr PrintHexByte
		jsr PrintSpace
	}
	FOR X = 0 to 7 {
		txa
		tay
		lda (@ADDR),Y
		IF (< 128) {
			IF (== 0) {
				lda #'.'H
			}
			ELSE {
				clc
				adc #128
			}
		}
		jsr PrintChar
	}
	
	RETURN
}
sub Loop_Paginate {
	var LINENUM 	= %R9.b					; line count
	var STOP 		= %R10.b				; stop scrolling

	inc @LINENUM
	lda @LINENUM							; Pause every N_LINES_PER_PAGE lines (not 24, as there is a header)
	if (== N_LINES_PER_PAGE) {
		jsr GetChar
		if (== $83) {						; Stop scrolling on ^C
			lda #1
			sta @STOP
		}
		if (== $9B) {						; Stop scrolling on ESC
			lda #1
			sta @STOP
		}
		stz @LINENUM
	}

	jsr NextLine
	stz @TXTPOS
	
	RETURN
}


/*
 *  'poke' addr,value
 */
sub DoPoke {
	var ADDR 		= %R11.t			; starting address
	var VALUE 		= %R0.b				; line count

	lda.t @ARGN							; must specify a filename
	if (< 1) {
		lda.t #NoAddressErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}
	lda.t @ARGT1						; move the address to @ARGT0
	sta.t @ARGT0
	jsr ParseNumber
	and.t #$FFFFF0						; round down to multiple of 16
	sta.t @ADDR

	lda.t @ARGN							; must specify a filename
	if (< 2) {
		lda.t #NoValueErrStr
		sta.t @ARGT0
		jsr PrintError
		RETURN
	}
	lda.t @ARGT2						; move the value to @ARGT0
	sta.t @ARGT0
	jsr ParseNumber
	and.t #$FFFFF0						; round down to multiple of 16
	sta.t @VALUE

	jsr NextLine

	lda.t @VALUE
	IF (< 0x0FF) {
		sta.b @ADDR
		bra +skip
	}
	IF (< 0x0FFFF) { // @@@ NEED ELSEIF
		sta.w @ADDR
	}
	ELSE {
		sta.t @ADDR
	}
  skip:

	lda.t @ADDR
	and.t #$FFFFF0
	sta.t @ADDR
	jsr Draw_Peek_Line
	jsr NextLine
	jsr NextLine

	RETURN
}



/*
 *  'reset' - restarts at the beginning on the ROM
 *  @@@ Add a warm restart flag like on the ][+
 */
sub DoReset {
	nop											; @@@ THERE IS A BUG THAT FAILS TO COUNT THE LENGTH OF IF THERE IS JUST ONE OPCODE
	jmp Reset
}


/*
 *  'text' - Switch to the TEXT screen (screen 1 or screen 2)
 */
sub DoText {
	lda.t @ARGN							; must specify a filename
	if (< 1) {
		lda TXTPAGE1
		stz @DISPMODE
		RETURN
	}

	ldy #0
	lda.a24 (@ARGT1),Y
	cmp #'8'
	if (==) {
		ldy #1
		lda.a24 (@ARGT1),Y
		cmp #'0'
		if (==) {
			ldy #2
			lda.a24 (@ARGT1),Y
			if (==) {
				// @@@ 80 column mode
				// RETURN
			}
		}
		lda.t #InvalidValue
		sta.t @ARG0
		jsr PrintError
		RETURN
	}
	cmp #'1'
	if (==) {
		ldy #1
		lda.a24 (@ARGT1),Y
		if (==) {
			lda TXTPAGE1
			stz @DISPMODE
			RETURN
		}
	}
	cmp #'2'
	if (==) {
		ldy #1
		lda.a24 (@ARGT1),Y
		if (==) {
			lda TXTPAGE2
			lda #DISP_TEXT_2
			sta @DISPMODE
			RETURN
		}
	}

	lda.t #InvalidValue
	sta.t @ARG0
	jsr PrintError
	RETURN
}


/*
 *  Jump to the 6502 RST vector
 */
sub Do2Plus {
	sta LANGCLR					; disable the ][+ "upper" 16K (one write is sufficent)
	sws							; Reset the stack width to 8-bits
	ldx #$ff 					; Reset the stack to $1FF
	txs
	lda #0
	sta PWREDUP 				; Make sure the Apple ][ ROM thinks this is a fresh reboot
	jmp (RSTVECTOR)				; Jump to the 6502 64K RST vector
}


/*
 *  'zzz' @@@ DEBUGGING
 */
sub DoZzz {
	lda.t #100000
	jsr PrintHexWord
	jsr PrintSpace
	lda.t #100000
	jsr Wait
	jsr PrintHexByte
	jsr PrintSpace
	jsr PrintSpace

	lda.t #200000
	jsr PrintHex24
	jsr PrintSpace
	lda.t #200000
	jsr Wait
	jsr PrintHexByte
	jsr PrintSpace
	jsr PrintSpace

	lda.t #800000
	jsr PrintHex24
	jsr PrintSpace
	lda.t #800000
	jsr Wait
	jsr PrintHexByte
	jsr PrintSpace
	jsr PrintSpace

	jsr NextLine

	rts.a24
}
