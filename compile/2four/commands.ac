/*
 *  ROM for the mythical Apple ][4
 *
 *  Shell-level commands
 *
 */

const N_LINES_PER_PAGE = 22

/*
 *  '?' - List the commands
 */
sub DoHelp(ARGN %%0) {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6
	var COL	= @$06						; column 0/12/24

	jsr NextLine
	
	lda.t #CommandListStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	@I = 1
	@COL = 0
	DO {
		jsr PrintSpace

		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t %%7
		jsr PrintString

		lda @COL
		IF ==  {
			@COL = 1
			@TXTPOS = 12
		}
		ELSE {
			IF == 1 {
				@COL = 2
				@TXTPOS = 24
			}
			IF == 2 {
				@COL = 0
				jsr NextLine		
			}
		}

		inc @I
		lda @I
	}
	WHILE (< N_COMMANDS)
	
	jsr NextLine		
	jsr NextLine		

	RETURN
}


/*
 *  'ascii' - Show all the ASCII characters
 */
sub DoAscii(ARGN %%0) {
	var I	= @$04						; loop variable
	var J	= @$05						; I * 6
	var C	= @$03						; (@I << 4) + J

	jsr NextLine
	
	lda.t #ASCIIHeaderStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	lda.t #ASCIIDashesStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	FOR @I = 0 TO 15 {
		lda @I							; Print 0-F row value
		jsr PrintHexDigit
		lda #'-'H
		jsr PrintChar

		FOR @J = 0 TO 15 {
			lda @C						; A = (@I << 4) + J
			jsr PrintChar
			inc @C
		}

		jsr NextLine
	}

	lda.t #ASCIIDashesStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	RETURN
}


/*
 *  'catalog' - Show the list of files on the harddisk or floppy
 */
sub DoCatalog(ARGN %%0) {
	jsr NextLine
	
	lda.t #CatalogHeaderStr
	sta.t %%7
	jsr PrintString
	jsr Disk4Name
	stx.t %%7
	jsr PrintString
	jsr NextLine

	jsr Disk4CatalogStart
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	jsr NextLine

	LOOP {
		jsr Disk4CatalogNext
		if (!=) {
			BREAK
		}
		stx.t %%7

		lda #2						; Print type (3 chars)
		sta @TXTPOS		
		lda DISK4_RAM
		jsr PrintChar
		lda DISK4_RAM+1
		jsr PrintChar
		lda DISK4_RAM+2
		jsr PrintChar

		lda #6						; Print size (3 numeric chars)
		sta @TXTPOS		
		lda DISK4_RAM+3
		jsr PrintChar
		lda DISK4_RAM+4
		jsr PrintChar
		lda DISK4_RAM+5
		jsr PrintChar

		lda #10						; Print filename
		sta @TXTPOS		
		jsr PrintString
		
		jsr NextLine
	}
	jsr NextLine

	RETURN
}


/*
 *  'clear'
 */
sub DoClear(ARGN %%0) {
	lda @DISPMODE
	if (==) {
		ldx #2
		jsr ClearScreen
		lda #2
		sta @TXTROW						; Start at row 2
		lda #0
		sta @TXTPOS						; Start at position 0
		RETURN
	}
	if (== DISP_TEXT_2) {
		ldx #0
		jsr ClearScreen
	}
	RETURN
}


/*
 *  'echo'
 */
sub DoEcho(ARGN %%0, INPUT @$200) {
	lda #@INPUT
	sta.t %%7
	jsr PrintString
	jsr NextLine
	RETURN
}


/*
 *  'load' filename,address
 *
 */
sub DoLoad(ARGN %%0, CMD %%0.1, FILENAME %%0.4, ADDRESS %%0.7) {
	jsr NextLine

	lda @ARGN						; must specify a filename
	if (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda @ARGN						; and an address
	if (< 2) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	lda.t @ADDRESS					; move the address to @STR
	sta.t %%7
	jsr ParseNumber
	sta.t @ADDRESS

	lda.t @FILENAME					; filename exists?
	if (==) {
		lda #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R9.b
	sta.t %%6
	jsr Disk4Open
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN

	var R_IDX = %R3.t					; index of total bytes read across all loops
	var ACTUAL = %R6.w					; actual bytes read per Disk4Read
	var C_IDX = %R8.w					; bytes copied from the read buffer

	stz.t @R_IDX
	LOOP {
		jsr Disk4Read
		if (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t DISK4_RET0				; Or check for zero byes (to be safe)
		if (==) {
			BREAK
		}
		sta.t @ACTUAL

		stz.w @C_IDX
		LOOP {
			ldx.w #DISK4_RAM			; Load from $C800,Y
			ldy.w @C_IDX
			lda.a24 XY
			inc.t @C_IDX

			ldx.t @ADDRESS				; Store in @ADDRESS,Y
			ldy.t @R_IDX
			sta.a24 XY
			inc.t @R_IDX

			ldy.w @C_IDX				; Until @C_IDX == @ACTUAL
			cpy.w @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

	lda @FN
	jsr Disk4Close

	lda.t #LoadedStr
	sta.t %%7
	jsr PrintString

	lda.t @ACTUAL
	jsr PrintHex24

	lda.t #LoadedBytesToStr
	sta.t %%7
	jsr PrintString

	lda.t @ADDRESS
	jsr PrintHex24

	jsr NextLine
	jsr NextLine

	RETURN
}


/*
 *  'view'
 */
sub DoView(ARGN %%0, CMD %%0.1, FILENAME %%0.4) {
	jsr NextLine

	lda @ARGN						; must specify a filename
	if (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R11.b
	lda.t @FILENAME
	sta.t %%6
	jsr Disk4Open
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN

	var R_IDX 		= %R3.t				; index into the read buffer
	var ACTUAL 		= %R6.t				; actual bytes read per Disk4Read
	var LINENUM 	= %%0.255.b			; line count

	stz @LINENUM
	LOOP {
		jsr Disk4Read
		if (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t DISK4_RET0				; Or check for zero byes (to be safe)
		if (==) {
			BREAK
		}
		sta.t @ACTUAL

		stz.t @R_IDX
		LOOP {
			ldx.w #DISK4_RAM			; Load from $C800,Y
			ldy.w @R_IDX
			lda.a24 XY
			IF (== 10) {
				jsr View_Paginate
				if (!=) {
					BREAK
				}
			}
			IF (>= 32) {				; Only visible characters
				ldy @TXTPOS
				cpy #40					; The next pos is off the screen, so newline
				IF (>=) {
					jsr View_Paginate
					if (!=) {
						bra +done
					}
					CONTINUE
				}
				ora #$80				; High ASCII
				sta (@TXTPTR),y
				inc @TXTPOS
			}

			inc.t @R_IDX
			lda.t @R_IDX
			cmp.t @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

  done:
	lda @FN
	jsr Disk4Close

	lda @LINENUM						; Pause every N_LINES_PER_PAGE lines (not 24, as there is a header)
	if (== N_LINES_PER_PAGE-1) {
		jsr GetChar
	}
	jsr NextLine

	RETURN
}
sub View_Paginate(LINENUM %%0.255.b) {
	inc @LINENUM
	lda @LINENUM				; Pause every N_LINES_PER_PAGE lines (not 24, as there is a header)
	if (== N_LINES_PER_PAGE) {
		jsr GetChar
		if (== $83) {			; Stop scrolling on ^C
			RETURN 1
		}
		if (== $9B) {			; Stop scrolling on ESC
			RETURN 1
		}
		stz @LINENUM
	}

	jsr NextLine
	stz @TXTPOS
	ldy @TXTPOS
	
	RETURN 0
}


/*
 *  'peek' addr[,addr] or addr[,+length]
 */
sub DoPeek(ARGN %%0, CMD %%0.1, START_ADDR %%0.4, END_ADDR %%0.7) {
	var LINENUM 	= %%0.255.b				; line count
	var CUR_ADDR 	= %%0.252.t				; current address
	var ADDR 		= %R3.t

	lda @ARGN								; must specify a filename
	if (< 1) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda.t @START_ADDR						; move the address to @STR
	sta.t %%7
	jsr ParseNumber
	and.t #$FFFFF0							; round down to multiple of 16
	sta.t @START_ADDR

	lda @ARGN								; and an address
	if (>= 2) {
		ldx.t @END_ADDR
		lda.a24 X
		cmp #'+'
		if (==) {							; +length 
			inx.t							; address+1 to skip the '+'
			stx.t %%7
			jsr ParseNumber
			tax.t							; @END = @START + length
			lda.t @START_ADDR
			adx.t
			sta.t @END_ADDR
		}
		ELSE {
			stx.t %%7
			jsr ParseNumber
			sta.t @END_ADDR
		}
	}
	ELSE {
		lda.t @START_ADDR
		clc
		adc.t #$40
		sta.t @END_ADDR
	}

	stz @LINENUM
	lda.t @START_ADDR
	sta.t @CUR_ADDR
	LOOP {
		jsr Draw_Peek_Line
		jsr Loop_Paginate
		if (!=) {
			BREAK
		}

		lda.t @CUR_ADDR
		clc
		adc.t #8
		sta.t @CUR_ADDR
		cmp.t @END_ADDR
		if (>=) {
			BREAK
		}
	}
	RETURN
}
sub Draw_Peek_Line(CUR_ADDR %%0.252.t) {
	var IDX 		= %R0.b
	var ADDR 		= %R3.t

	lda.t @CUR_ADDR
	sta.t @ADDR

	lda #'$'H						; $addr- xx xx xx xx xx xx xx xx ........
	jsr PrintChar
	lda.t @ADDR
	jsr PrintHex24
	lda #'-'H
	jsr PrintChar

	FOR @IDX = 0 to 7 {				; Print the value as $HH
		ldy @IDX
		lda.a24 (@ADDR),Y
		jsr PrintHexByte
		jsr PrintSpace
	}
	FOR @IDX = 0 to 7 {
		ldy @IDX
		lda.a24 (@ADDR),Y
		IF (< 128) {				; Print the (HIGH) ASCII equivalent of the value (except $00 = '.')
			IF (== 0) {
				lda #'.'H
			}
			ELSE {
				clc
				adc #128
			}
		}
		jsr PrintChar
	}
	
	RETURN
}
sub Loop_Paginate(LINENUM %%0.255.b) {
	inc @LINENUM
	lda @LINENUM							; Pause every N_LINES_PER_PAGE lines (not 24, as there is a header)
	if (== N_LINES_PER_PAGE) {
		jsr GetChar
		if (== $83) {						; Stop scrolling on ^C
			RETURN 1
		}
		if (== $9B) {						; Stop scrolling on ESC
			RETURN 1
		}
		stz @LINENUM
	}

	jsr NextLine
	stz @TXTPOS
	
	RETURN 0
}


/*
 *  'poke' addr,value
 */
sub DoPoke(ARGN %%0, CMD %%0.1, ADDRESS %%0.4, VALUE %%0.7) {
	var CUR_ADDR 	= %%0.252.t			; current address

	lda @ARGN							; must specify a filename
	if (< 1) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda.t @ADDRESS						; move the address to @STR
	sta.t %%7
	jsr ParseNumber
	sta.t @ADDRESS

	lda @ARGN							; must specify a value
	if (< 2) {
		lda.t #NoValueErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda.t @VALUE						; move the value to @STR
	sta.t %%7
	jsr ParseNumber
	sta.t @VALUE

	jsr NextLine

	ldx.t @ADDRESS
	lda.t @VALUE
	cmp.t #0xFF
	IF (<) {
		sta.a24.b X
		bra +skip
	}
	cmp.t #0xFFFF
	IF (<) { 							;; @@@ NEED ELSEIF
		sta.a24.w X
	}
	ELSE {
		sta.a24.t X
	}
  skip:

	lda.t @ADDRESS
	and.t #$FFFFF0
	sta.t @CUR_ADDR
	jsr Draw_Peek_Line
	jsr NextLine
	jsr NextLine

	RETURN
}



/*
 *  'run' filename
 *
 */
sub DoRun(ARGN %%0, CMD %%0.1, FILENAME %%0.4) {
	jsr NextLine

	lda @ARGN							; must specify a filename
	if (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	lda.t @FILENAME						; filename exists?
	if (==) {
		lda #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	sta.t %%6
	jsr Disk4Exists
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	lda.t DISK4_RAM						; The type is returned in $C800-$C802
	cmp.t #$ced5d2						; "NUR" = "RUN" loaded as one little-endian 24-bit value
	if (!=) {
		lda.t #NotRUNFileError
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R9.b
	jsr Disk4Open
	if (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN

	var R_IDX = %R3.t					; index of total bytes read across all loops
	var ACTUAL = %R6.w					; actual bytes read per Disk4Read
	var C_IDX = %R8.w					; bytes copied from the read buffer

	stz.t @R_IDX
	LOOP {
		jsr Disk4Read
		if (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t DISK4_RET0				; Or check for zero byes (to be safe)
		if (==) {
			BREAK
		}
		sta.t @ACTUAL

		stz.w @C_IDX
		LOOP {
			ldx.w #DISK4_RAM			; Load from $C800,Y
			ldy.w @C_IDX
			lda.a24 XY
			inc.t @C_IDX

			ldx.t #$10000				; Store in $10000 (after the first 64K ends)
			ldy.t @R_IDX
			sta.a24 XY
			inc.t @R_IDX

			ldy.w @C_IDX				; Until @C_IDX == @ACTUAL
			cpy.w @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

	lda @FN
	jsr Disk4Close

	jsr NextLine

	dec @ARGN							; Shift all the args down by one (the FILENAME becomes the CMD)
	lda @ARGN
	sta %R0
	clc
	adc %R0
	adc %R0
	adc.t #$D001
	sta.t %R0
	ldx.t #$D001
	LOOP {								; End the loop at $D000 + (ARGN-1) * 3 + 1
		ldy #3							; Copy $Dnnn+3 (XY) to #Dnnn (X)
		lda.t XY
		sta.t X

		inx.t
		inx.t
		inx.t
		cpx.t %R0
		IF (>=) {
			BREAK
		}
	}


	jsr $10000							; Run the program

	RETURN
}


/*
 *  'reset' - restarts at the beginning on the ROM
 *  @@@ Add a warm restart flag like on the ][+
 */
sub DoReset(ARGN %%0) {
	nop											; @@@ THERE IS A BUG THAT FAILS TO COUNT THE LENGTH OF IF THERE IS JUST ONE OPCODE
	jmp Reset
}


/*
 *  'text' - Switch to the TEXT screen (screen 1 or screen 2)
 */
sub DoText(ARGN %%0, CMD %%0.1, WHERE %%0.4) {
	lda @ARGN
	if (< 1) {
		lda TXTPAGE1
		stz @DISPMODE
		RETURN
	}

	ldx.t @WHERE
	lda.a24 X
	cmp #'8'
	if (==) {
		ldy #1
		lda.a24 XY
		cmp #'0'
		if (==) {
			ldy #2
			lda.a24 XY
			if (==) {
				// @@@ 80 column mode
				// RETURN
			}
		}
		lda.t #InvalidValue
		sta.t %%7
		jsr PrintError
		RETURN
	}
	cmp #'1'
	if (==) {
		ldy #1
		lda.a24 XY
		if (==) {
			lda TXTPAGE1
			stz @DISPMODE
			RETURN
		}
	}
	cmp #'2'
	if (==) {
		ldy #1
		lda.a24 XY
		if (==) {
			lda TXTPAGE2
			lda #DISP_TEXT_2
			sta @DISPMODE
			RETURN
		}
	}

	lda.t #InvalidValue
	sta.t %%7
	jsr PrintError
	RETURN
}


/*
 *  Jump to the 6502 RST vector
 */
sub Do2Plus(ARGN %%0) {
	sta LANGCLR					; disable the ][+ "upper" 16K (one write is sufficent)
	sws							; Reset the stack width to 8-bits
	ldx #$ff 					; Reset the stack to $1FF
	txs
	lda #0
	sta PWREDUP 				; Make sure the Apple ][ ROM thinks this is a fresh reboot
	jmp (RSTVECTOR)				; Jump to the 6502 64K RST vector
}
