/*
 *  ROM for the mythical Apple ][4
 *
 *  Utility subroutines
 *
 */


/*
 *  Compute the TEXT screen pointer
 */
sub ScreenBase {
	X = @TXTROW							; X = @TXTROW
	xsl									; X = X * 2

	lda.w TextScreenBase,x				; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	rts.a24
}

/*
 *  Compare the text buffer with a string
 *  @ARGT0.a24 points to one string
 *  @ARGT1.a24 points to another string
 *  Return in A = #FF if match, #00 if not
 */
sub CompareText {
	FOR Y = 0 TO 127 {
		lda.a24 (@ARGT0),y
		cmp.a24 (@ARGT1),y
		IF != {
			RETURN 0
		}
		IF == 0 {
			lda.a24 (@ARGT1),y
			IF == 0 {
				RETURN $FF
			}
			RETURN 0
		}
	}
	RETURN 0
}

/*
 *  Compare the text buffer with a string
 *  @ARGT0.a24 points to one string
 *  @ARGT1.a24 points to another string
 *  Return in A = #FF if ARGT0 matches the start of ARGT1, #00 if not
 */
sub CompareStartOfText {
	FOR Y = 0 TO 127 {
		lda.a24 (@ARGT0),y
		IF == 0 {
			RETURN $FF
		}
		cmp.a24 (@ARGT1),y
		IF != {
			RETURN 0
		}
	}
	RETURN 0
}


/*
 *  Copy one string to another
 *  @ARGT0.a24 points to the orignal
 *  @ARGT1.a24 points to destination
 */
sub CopyString {
	FOR Y = 0 TO 127 {
		lda.a24 (@ARGT0),y
		if == {
			RETURN
		}
		sta.a24 (@ARGT1),y
	}
	RETURN
}


/*
 *  Copy one string to another
 *  @ARGT0.a24 points to the orignal
 *  @ARGT1.a24 points to destination
 */
sub CopyStringHigh {
	FOR Y = 0 TO 127 {
		lda.a24 (@ARGT0),y
		if == {
			RETURN
		}
		ora #$80
		sta.a24 (@ARGT1),y
	}
	RETURN
}


/*
 *  Print a 24-bit hex value
 *  A.t = value to print
 */
sub PrintHex24 {				
	pha.t
	pha.t
	sr8.t
	sr8.t
	jsr PrintHexByte
	pla.t
	sr8.w
	jsr PrintHexByte
	pla.t
	jsr PrintHexByte
	rts.a24
}


/*
 *  Print a 16-bit hex value
 *  A.w = value to print
 */
sub PrintHexWord {				
	pha.w
	sr8.w
	jsr PrintHexByte
	pla.w
	jsr PrintHexByte
	rts.a24
}


/*
 *  Print a hex byte
 *  A = value to print
 */
sub PrintHexByte {				
	pha
	lsr
	lsr
	lsr
	lsr
	jsr PrintHexDigit
	pla
	and #$0F
	jsr PrintHexDigit
	rts.a24
}


/*
 *  Print a hex digit
 *  A = nibble to print
 */
sub PrintHexDigit {
	cmp #10
	bcc +print_hex_digit_09
	clc
	adc #$B7
	bra +print_hex_digit
 print_hex_digit_09:
	adc #$B0
 print_hex_digit:
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	rts.a24
}


/*
 *  Parse a value
 *    @ARGT0.a24 points to the string
 *	  Returns value in A
 */
sub ParseNumber {
	lda.a24 (@ARGT0)
	cmp #'$'
	IF (==) {					; $HEX value
		jmp ParseHexNumber
	}
	ELSE {								; DECIMAL value		
		jmp ParseDecimalNumber
	}
}
sub ParseHexNumber {
	var VAL = %R0.t					; Holds the value being generated
	stz.t @VAL

	ldy #1							; Y = 1, to skip the leading '$'
	LOOP {
		lda.a24 (@ARGT0),Y
		IF (==) {					; Zero terminated string
			BREAK
		}

		lda.t @VAL					; @VAL <<= 4, making space for the next nibble
		asl.t
		asl.t
		asl.t
		asl.t
		sta.t @VAL

		lda.a24 (@ARGT0),Y
		cmp #'0'
		IF (>=) {
			cmp #'9'
			IF (<=) {
				sec
				sbc #'0'			; @VAL += C - '0'
				clc
				adc.t @VAL
				sta.t @VAL
				iny
				CONTINUE
			}
			cmp #'A'
			IF (>=) {
				cmp #'G'
				IF (<=) {
					sec
					sbc #55			; @VAL += C - 'A' + 10
					clc
					adc.t @VAL
					sta.t @VAL
					iny
					CONTINUE
				}
				cmp #'a'
				IF (>=) {
					cmp #'g'
					IF (<=) {
						sec
						sbc #87	; @VAL += C - 'a' + 10
						clc
						adc.t @VAL
						sta.t @VAL
						iny
						CONTINUE
					}
				}
			}
			}
			BREAK						; Stop for any character not 0-9A-Za-z
	}

	lda.t @VAL
	RETURN
}
sub ParseDecimalNumber {
	var VAL = %R0.t					; Holds the value being generated
	stz.t @VAL

	ldy #0
	LOOP {
		lda.a24 (@ARGT0),Y
		IF (==) {					; Zero terminated string
			BREAK
		}

		lda.t @VAL					; @VAL *= 10 (VAL = VAL*8 + VAL*2)
		jsr Times10
		sta.t @VAL

		lda.a24 (@ARGT0),Y
		cmp #'0'
		IF (>=) {
			cmp #'9'
			IF (<=) {
				sec
				sbc #'0'			; @VAL += C - '0'
				clc
				adc.t @VAL
				sta.t @VAL
				iny
				CONTINUE
			}
			BREAK
		}
	}

	lda.t @VAL
	RETURN
}


/*
 *  Calculate A * 10
 *    A = value
 *	  X is clobbered
 *	  Returns A = A * 10
 */
sub Times10 {
	asl.t							; A *= 10 (A = A*8 + A*2)
	tax.t
	asl.t
	asl.t
	clc
	adx.t
	rts.a24
}


/*
 *  Calculate A.t mod X.t
 *    A = value
 *	  X = modulo
 *	  Returns Y = A mod X, X = A / X
 */
sub Modulo {
	var MODULO = %R12.t
	stx.t @MODULO
	ldy #0
	LOOP {
		sec
		sbc.t @MODULO
		if (-) {
			clc
			adc.t @MODULO
			RETURN
		}
		iny
	}
}



/*
 *  Print a string
 *  @ARGT0.a24 points to the string
 */
sub PrintString {
	FOR X = 0 TO 39 {
		txa
		tay
		lda.a24 (@ARGT0),y
		beq +BREAK
		ora #$80
		ldy @TXTPOS
		cpy #40 					; ignore if >= column 40
		IF < {
			sta (@TXTPTR),y
			inc @TXTPOS
		}
	}
	RETURN
}
sub PrintError {
	jsr NextLine
	jsr PrintString
	jsr NextLine
	jsr NextLine
	RETURN
}


/*
 *  Print a character
 *  A = ASCII character
 */
sub PrintChar {
	ldy @TXTPOS
	cpy #40 					; ignore if >= column 40
	IF < {
		sta (@TXTPTR),y
		inc @TXTPOS
	}
	RETURN
}


/*
 *  Print a blank space
 */
sub PrintSpace {
	lda #' 'H
	ldy @TXTPOS
	cpy #40 					; ignore if >= column 40
	IF < {
		sta (@TXTPTR),y
		inc @TXTPOS
	}
	RETURN
}


/*
 *  Print the cursor
 *  A = ASCII character
 *  TXTPOS is NOT updated
 */
sub PrintCursor {
	ldy @TXTPOS
	cpy #40 					; ignore if >= column 40
	IF < {
		lda #'_'H
		sta (@TXTPTR),y
	}
	RETURN
}


/*
 *  Unprint the cursor
 *  TXTPOS is NOT updated
 */
sub ClearCursor {
	ldy @TXTPOS
	cpy #40 					; ignore if >= column 40
	IF < {
		lda #' 'H
		sta (@TXTPTR),y
	}
	RETURN
}


/*
 *  Play a beep sound - waveform is in BeepTimes
 */
sub PlayBeep {
	FOR X = 0 TO 8 {
		lda BeepTimes,X				; for Wait $nn = .01 seconds
		FOR Y = 0 TO 16 {
			jsr Wait
			bit SPKR				; toggle the speaker
		}
	}
	RETURN
}


/*
 *  Pause for A/100000 seconds
 */
sub Wait {
	phx.t
	pha.t
	FOR X = 1 TO 3 {			; 3 times is the magic number for 4Mhz
		pla.t
		pha.t					; countdown A to zero
		DO {
			dec.t
			cmp.t #0
		}
		WHILE (!=)
	}
	pla.t
	plx.t
	RETURN
}


/*
 *  Print a hex byte in the top right corner of the screen
 *  A = value to print
 */
sub PrintDebugValue {				
	pha						; Save A
	pha						; Copy A for 2nd digit
	A >>= 4					; Draw hex of 1st nibble
	IF >= 10 {
		A += $B7
	}
	ELSE {
		A += $B0
	}
	sta $426				; Hardcoded to top-right corner of the TEXT screen
	pla						; Draw hex of 2nd nibble
	A &= $0F
	IF >= 10 {
		A += $B7
	}
	ELSE {
		A += $B0
	}
	sta $427				; Hardcoded to top-right corner of the TEXT screen
	pla						; Restore A
	RETURN
}

/*
 *  Print one character in the top right corner of the screen
 *  A = char to print
 */
sub PrintDebugChar {				
	sta $427
	lda #$A0
	sta $426
	rts.a24
}
sub PrintDebug2Chars {				
	sta.w $426
	rts.a24
}


/*
 *  Fill the TEXT row with spaces
 *  X = row to clearing
 */
sub ClearRow {
	xsl									; X = X * 2
	lda.w TextScreenBase,x				; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda #$A0 							; $20 (space) | $80 (high ASCII)
	ldy #0
 loop_clear_char:
	sta (@TXTPTR),y
	iny
	cpy #40								; 40 columns wide
	bne -loop_clear_char
	rts.a24
}


/*
 *  Fill the TEXT screen with spaces from row X to row 23
 *  X = first row to start clearing
 */
sub ClearScreen {
	var ROWPTR = %R0.t

	xsl									; X = X * 2
	DO {
		lda.t TextScreenBase,X			; Pre-calculated row values
		ldy @DISPMODE
		cpy #DISP_TEXT_2				; TEXT page 2
		IF (==) {
			clc
			adc.t #$400
		}
		sta.w @ROWPTR

		lda #$A0 						; $20 (space) | $80 (high ASCII)
		FOR Y = 0 TO 39 {				; 40 columns
			sta (@ROWPTR),y
		}
		inx
		inx
		cpx #48							; 24 rows (x2 bytes pre row pointer)
	}
	WHILE (!=)
	RETURN
}

/*
 *  Check to see if the TEXT screen needs to be scrolled, and if so, scroll
 */
sub NextLine {
	lda @TXTROW							; 24 rows tall (0-23)
	cmp #23
	IF < {
		inc @TXTROW						; Increment the current row
		jsr ScreenBase					; Update the @TXTPTR
		lda #0
		sta @TXTPOS						; Reset to position 0
	}
	ELSE {
		ldx #2
		jsr ScrollScreen				; Scroll the screen, from row X=2
		lda #23
		sta @TXTROW						; Set to row 23
		lda #0
		sta @TXTPOS						; Reset to position 0
	}
	RETURN
}


/*
 *  Scroll the TEXT screen with spaces from row X to row 23
 *  X = first row to start clearing
 */
sub ScrollScreen {
  xsl											; X = X * 2
 loop_scroll_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda.w TextScreenBase+2,x
	sta.w $00								; $00-$01 = address of the next line on the TEXT screen
	ldy #0
 loop_scroll_char:
	lda ($00),y
	sta (@TXTPTR),y
	iny
	cpy #40									; 40 columns
	bne -loop_scroll_char
	inx
	inx
	cpx #46									; Only 23 rows (46 = 23 x 2), as the the last line gets cleared
	bne -loop_scroll_line
 scroll_clear_last_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda.w #$A0A0						; Two ' 's
	ldy #0
 loop_scroll_clear_line:
	sta.w (@TXTPTR),y
	iny
	iny
	cpy #40
	bne -loop_scroll_clear_line
 done_with_scroll:
	rts.a24
}


/*
 *  Clear the text input buffers (255 bytes, filled with zeros)
 */
sub ClearInputBuffers {
	lda #0
	FOR X = 0 TO 255 {
		sta @TXTBUFFER,x
	}
	rts.a24
}


/*
 *  Clear the text input buffer (128 bytes, filled with zeros)
 */
sub ClearCurrentInputBuffer {
	lda #0
	FOR X = 0 TO 127 {
		sta @TXTBUFFER,x
	}
	RETURN
}

/*
 *  Copy the previous input buffer into the current buffer (128 bytes)
 */
sub PrevToCurrentInputBuffer {
	FOR X = 0 TO 127 {
		lda @TXTBUFFER2,x
		sta @TXTBUFFER,x
	}
	RETURN
}
/*
 *  Copy the previous input buffer into the current buffer (128 bytes)
 */
sub CurrentToPrevInputBuffer {
	FOR X = 0 TO 127 {
		lda @TXTBUFFER,x
		sta @TXTBUFFER2,x
	}
	RETURN
}


/*
 *  Copy the current text input buffer to the current line on the TEXT screen
 */
sub InputBufferToTextScreen {
	ldy #1
	FOR X = 0 TO 39 {
		lda @TXTBUFFER,x
		if (== 0) {
			sty @TXTPOS
			BREAK
		} 
		ora #$80
		sta (@TXTPTR),y
		iny
	}
	lda #' 'H
	LOOP {
		cpy #40
		IF (==) {
			BREAK
		}
		sta (@TXTPTR),y
		iny
	}
	RETURN
}


/*
 *  Wait for a key to be pressed
 *  Returns: ASCII (high bit set) in A
 */
sub GetChar {
	LOOP {
		bit KBD 					; check keyboard for next key
		IF - {
			BREAK
		}
	}
	lda KBD 						; get the key code from the keyboard
	bit KBDSTRB						; clear keyboard strobe (a.k.a. ack keyboard read)
	rts.a24
}



/*
 *  Print Apple ][4 at the top of the screen
 */
sub AppleII4 {
	FOR X = 0 TO 39 {
		lda Hello,x
		beq +BREAK
		ora #$80
		sta $400,x
	}
	RETURN
}
