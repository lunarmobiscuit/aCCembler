/*
 *  ROM for the mythical Apple ][4
 *
 *  pomme -l Apple2four.lst -o Apple2four.rom Apple2four.pom 
 *
 */

const KBD         = $c000		// R last key pressed + 128
const KBDSTRB     = $c010		// RW keyboard strobe
const TAPEOUT     = $c020		// RW toggle caseette tape output
const SPKR        = $c030		// RW toggle speaker
const TXTCLR      = $c050		// RW display graphics
const TXTSET      = $c051		// RW display text
const MIXSET      = $c053		// RW display split screen
const TXTPAGE1    = $c054		// RW display page 1
const LORES       = $c056		// RW display lo-res graphics
const SETAN0      = $c058		// RW annunciator 0 off
const SETAN1      = $c05a		// RW annunciator 1 off
const CLRAN2      = $c05d		// RW annunciator 2 on
const CLRAN3      = $c05f		// RW annunciator 3 on
const TAPEIN      = $c060		// R cassete tape input
const PADDL0      = $c064		// R analog input 0
const PTRIG       = $c070		// RW analog input reset
const CLRROM      = $cfff		// disable slot C8 ROM
const RSTVECTOR   = $fffc  	// Apple ][ 6502 reset vector
const PWREDUP     = $03f4  	// Apple ][ stores #$A5 to make RST a soft reboot

global TXTPTR 		= @$FE.a16	// $FE-$FF is the address of the current line of text
global TXTROW 		= @$3FF			// $3FF is the current row on the text screen
global TXTPOS 		= @$3FE			// $3FE is the current position (column) in the text screen
global TXTBUFFER 	= @$200			// $200-$2FF holds the line of text being typed

global ARG0				= @$00

/*
 *  The code begins with a JMPs to the OS functions
 *  (TBD: change all but the first JMP to a table of vectors and add JSR ($aaaa) address mode)
 */
sub Start @$FF0000 {
	jmp Reset
	jmp ClearScreen
	jmp ScrollScreen
}

/*
 *  RST vector points here
 */
sub Reset @$FF0200 {
	cld
	ldx #$ff
	txs
	lda TXTSET					; Start in TEXT mode
	lda TXTPAGE1				;  Page 1
	lda SETAN0					; AN0 = TTL hi
	lda SETAN1					; AN1 = TTL hi
	lda CLRAN2					; AN2 = TTL lo
	lda CLRAN3					; AN3 = TTL lo
	lda CLRROM					; turn off extension ROM
	bit KBDSTRB					; clear keyboard
	ldx #0
	jsr ClearScreen				; clear the screen (x = row 0)
	jsr AppleII4				; draw the header
	lda #2
	sta @TXTROW					; Start at TEXT row 2
	lda #0
	sta @TXTPOS					; Start at TEXT position 0
	jmp EchoKeys				; loop forever reading commands
}

/*
 *  Print Apple ][4 at the top of the screen
 */
sub AppleII4 {
  FOR X = 0 TO 255 {
		lda Hello,x
		beq +BREAK
		ora #$80
		sta $400,x
	}
	RETURN
}

/*
 *  Echo the keys as they are typed and store in @TXTBUFFER
 */
sub EchoKeys {
	jsr ClearInputBuffer
	LOOP {
		jsr ScreenBase					; Set the @TEXTPTR based on @TXTROW
		lda @TXTPOS
		IF == {
			lda #':'					; Draw the prompt
			jsr PrintChar
		}
		LOOP {
			bit KBD 					; check keyboard for next key
			IF - {
				BREAK
			}
		}
		lda KBD 						; get the key code from the keyboard
		bit KBDSTRB						; clear keyboard strobe (a.k.a. ack keyboard read)
		if == $8D {						; 13 = CR ($80 | $0D in high ASCII)
			jsr NextLine
			jsr CommandLine
			jsr ClearInputBuffer
			CONTINUE
		}						
		if == $88 {						; 8 = BS ($80 | $08 in high ASCII)
			lda @TXTPOS
			if > 1 {
				tay
				dey
				sty @TXTPOS
				lda #$A0				; High ASCII ' '
				sta (@TXTPTR),y
			}
			CONTINUE
		}
		if == $9B {						; 27 = ESC ($80 | $1B in high ASCII)
			ldx #2
			jsr ClearScreen				; clear the screen (x = row 2)
			lda #2
			sta @TXTROW					; reset to row 2
			lda #0
			sta @TXTPOS					; reset to position 0
			CONTINUE
		}
		if > $9F {						; 31 = Last control character ($80 | $1F in high ASCII)
			ldy @TXTPOS
			cpy #40 					; ignore if >= column 40
			IF != {
				sta (@TXTPTR),y
				and #$7F							; store (low) ASCII in TEXT buffer
				dey
				sta @TXTBUFFER,y
				inc @TXTPOS							; next position
			}
		}
	}
}

/*
 *  DEBUGGING
 */
data ShouldNotGetHere byte { $FE, $DB }

/*
 *  Lookup and execute the typed command
 */
sub CommandLine {
  lda.t #CMD_Clear
  sta.t @ARG0
	jsr CompareText
	IF != {
		jsr DoClear
		RETURN
	}

  lda.t #CMD_Memory
  sta.t @ARG0
	jsr CompareText
	IF != {
		jsr DoMemory
		RETURN
	}

  lda.t #CMD_Reset
  sta.t @ARG0
	jsr CompareText
	IF != {
		jsr DoReset
		RETURN
	}

  lda.t #CMD_2Plus
  sta.t @ARG0
	jsr CompareText
	IF != {
		jsr Do2Plus
		RETURN
	}

  lda.t #CMD_C081
  sta.t @ARG0
	jsr CompareText
	IF != {
		jsr DoC081
		RETURN
	}

  lda.t #CMD_C083
  sta.t @ARG0
	jsr CompareText
	IF != {
		jsr DoC083
		RETURN
	}

	RETURN
}

/*
 *  Compare the text buffer with a string
 *  @ARG0.a24 points to the string
 *  Return in A = #FF if match, #00 if not
 */
sub CompareText {
	FOR Y = 0 TO 39 {
		lda @TXTBUFFER,y
		cmp.a24 (@ARG0),y
		IF != {
			RETURN 0
		}
		IF == 0 {
			lda.a24 (@ARG0),y
			IF == 0 {
				RETURN $FF
			}
			RETURN 0
		}
	}
	RETURN 0
}

/*
 *  'clear'
 */
sub DoClear {
	ldx #2
	jsr ClearScreen
	lda #2
	sta @TXTROW						; Start at row 2
	lda #0
	sta @TXTPOS						; Start at position 0
	rts.a24
}

/*
 *  'memory'
 */
sub DoMemory {
	jsr NextLine
	lda #0
	jsr PrintHexByte
	lda #$AD
	jsr PrintChar
	jsr PrintSpace
	ldx #0
 loop_Memory:
	lda $00,x
	jsr PrintHexByte
	jsr PrintSpace
	inx
	cpx #8
	bne -loop_Memory
	jsr NextLine
	rts.a24
}

/*
 *  Print a hex byte
 *  A = value to print
 */
sub PrintHexByte {				
	pha
	lsr
	lsr
	lsr
	lsr
	jsr PrintHexDigit
	pla
	and #$0F
	jsr PrintHexDigit
	rts.a24
}

/*
 *  Print a hex digit
 *  A = nibble to print
 */
sub PrintHexDigit {
	cmp #10
	bcc +print_hex_digit_09
	clc
	adc #$B7
	bra +print_hex_digit
 print_hex_digit_09:
	adc #$B0
 print_hex_digit:
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	RETURN
}

/*
 *  Print a string
 *  @ARG0.a24 points to the string
 */
sub PrintString {
	FOR Y = 0 TO 255 {
		lda.t (@ARG0),y
		beq +BREAK
		sty $02
		ldy @TXTPOS
		sta (@TXTPTR),y
		inc @TXTPOS
		ldy $02
	}
	RETURN
}

/*
 *  Print a character
 *  A = ASCII character
 */
sub PrintChar {
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	RETURN
}

/*
 *  Print a space
 */
sub PrintSpace {
	lda #$A0
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	RETURN
}

/*
 *  Print a hex byte in the top right corner of the screen
 *  A = value to print
 */
sub PrintDebugValue {				
	pha

	pha
	A >>= 4
	IF >= 10 {
		A += $B7
	}
	ELSE {
		A += $B0
	}
	sta $426

	pla
	A &= $0F
	IF >= 10 {
		A += $B7
	}
	ELSE {
		A += $B0
	}
	sta $427

	pla
	RETURN
}

/*
 *  Print one character in the top right corner of the screen
 *  A = char to print
 */
sub PrintDebugChar {				
	sta $427
	lda #$A0
	sta $426
	RETURN
}
sub PrintDebug2Chars {				
	sta.w $426
	RETURN
}

/*
 *  Restart at the beginning on the ROM
 *  @@@ Add a warm restart flag like on the ][+
 */
sub DoReset {
	nop											; @@@ THERE IS A BUG THAT FAILS TO COUNT THE LENGTH OF IF THERE IS JUST ONE OPCODE
	jmp Reset
}

/*
 *  Jump to the 6502 RST vector
 */
sub Do2Plus {
	sws											; Reset the stack width to 8-bits
	ldx #$ff 								; Reset the stack to $1FF
	txs
	lda #0
	sta PWREDUP 						; Make sure the Apple ][ ROM thinks this is a fresh reboot
	jmp (RSTVECTOR)					; Jump to the 6502 64K RST vector
}

/*
 *  Compute the TEXT screen pointer
 */
sub ScreenBase {
	X = @TXTROW							; X = @TXTROW
  xsl											; X = X * 2
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	RETURN
}

/*
 *  Fill the TEXT screen with spaces from row X to row 23
 *  X = first row to start clearing
 */
sub ClearScreen {
  xsl											; X = X * 2
 loop_clear_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda #$A0 								; $20 (space) | $80 (high ASCII)
	ldy #0
 loop_clear_char:
	sta (@TXTPTR),y
	iny
	cpy #40									; 40 columns wide
	bne -loop_clear_char
	inx
	inx
	cpx #48									; 24 rows (x2 bytes pre row pointer)
	bne -loop_clear_line
	RETURN
}

; Check to see if the TEXT screen needs to be scrolled, and if so, scroll
sub NextLine {
	lda @TXTROW							; 24 rows tall (0-23)
	cmp #23
	beq +next_line_scroll
 next_line_next_row:
	inc @TXTROW							; Increment the current row
	jsr ScreenBase					; Update the @TXTPTR
	lda #0
	sta @TXTPOS							; Reset to position 0
	rts.a24
 next_line_scroll:
	ldx #2
	jsr ScrollScreen				; Scroll the screen, from row X=2
	lda #23
	sta @TXTROW							; Set to row 23
	lda #0
	sta @TXTPOS							; Reset to position 0
	RETURN
}

/*
 *  Scroll the TEXT screen with spaces from row X to row 23
 *  X = first row to start clearing
 */
sub ScrollScreen {
  xsl											; X = X * 2
 loop_scroll_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda.w TextScreenBase+2,x
	sta.w $00								; $00-$01 = address of the next line on the TEXT screen
	ldy #0
 loop_scroll_char:
	lda ($00),y
	sta (@TXTPTR),y
	iny
	cpy #40									; 40 columns
	bne -loop_scroll_char
	inx
	inx
	cpx #46									; Only 23 rows (46 = 23 x 2), as the the last line gets cleared
	bne -loop_scroll_line
 scroll_clear_last_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda.w #$A0A0						; Two ' 's
	ldy #0
 loop_scroll_clear_line:
	sta.w (@TXTPTR),y
	iny
	iny
	cpy #40
	bne -loop_scroll_clear_line
 done_with_scroll:
	RETURN
}

/*
 *  Clear the text input buffer (255 bytes, filled with zeros)
 */
sub ClearInputBuffer {
	lda #0
	ldx #$ff
 loop_clear_buffer:
	sta @TXTBUFFER,x
	dex
	bne -loop_clear_buffer
	sta $200
	RETURN
}


/*
 *  'c081' @@@ DEBUGGING
 */
sub DoC081 {
	lda $C081
	lda $C081
	jsr NextLine
	lda #$aa
	sta $E000
	lda #$E0
	jsr PrintHexByte
	lda #0
	jsr PrintHexByte
	lda #$AD
	jsr PrintChar
	jsr PrintSpace
	ldx #0
 loop_c081:
	lda $E000,x
	jsr PrintHexByte
	jsr PrintSpace
	inx
	cpx #8
	bne -loop_c081
	jsr NextLine
	rts.a24
}

/*
 *  'c083' @@@ DEBUGGING
 */
sub DoC083 {
	lda $C083
	lda $C083
	jsr NextLine
	lda @TXTPOS
	sta $E000
	lda $04
	sta $E001
	lda #$E0
	jsr PrintHexByte
	lda #0
	jsr PrintHexByte
	lda #$AD
	jsr PrintChar
	jsr PrintSpace
	ldx #0
 loop_c083:
	lda $E000,x
	jsr PrintHexByte
	jsr PrintSpace
	inx
	cpx #8
	bne -loop_c083
	jsr NextLine
	rts.a24
}


/*
 *  The addresses of the 24 TEXT rows
 */
data TextScreenBase @$FF8000 word {
	$0400, $0480, $0500, $0580, $0600, $0680, $0700, $0780
	$0428, $04A8, $0528, $05A8, $0628, $06A8, $0728, $07A8
	$0450, $04D0, $0550, $05D0, $0650, $06D0, $0750, $07D0
}


/*
 *  The title of the reset screen
 */
data Hello string {
	"Apple ][4"
}

/*
 *  The list of commands
 */
data CMD_Clear string { "clear" }
data CMD_Memory string { "memory" }
data CMD_Reset string { "reset" }
data CMD_2Plus string { "2+" }
data CMD_C081 string { "c081" }
data CMD_C083 string { "c083" }

data CommandListLength byte { 6 }
data CommandList u24 {
	CMD_Clear
	CMD_Memory
	CMD_Reset
	CMD_2Plus
	CMD_C081
	CMD_C083
}

/*
 *  The 6502 vectors
 */
data Vectors @$FFFFF7 u24 {
	$000000 	; NMI
	$FF0000 	; RESET
	$000000 	; IRQ
}
