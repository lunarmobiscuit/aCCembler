/*
 *  ROM for the mythical Apple ][4
 *
 *  pomme -l Apple2four.lst -o Apple2four.rom Apple2four.pom; cp Apple2four.rom ../../izapple2/resources 
 *
 */

const KBD			= $c000		// R last key pressed + 128
const KBDSTRB		= $c010		// RW keyboard strobe
const TAPEOUT		= $c020		// RW toggle caseette tape output
const SPKR			= $c030		// RW toggle speaker
const TXTCLR		= $c050		// RW display graphics
const TXTSET		= $c051		// RW display text
const MIXSET		= $c053		// RW display split screen
const TXTPAGE1		= $c054		// RW display page 1
const TXTPAGE2		= $c055		// RW display page 2
const LORES			= $c056		// RW display lo-res graphics
const SETAN0		= $c058		// RW annunciator 0 off
const SETAN1		= $c05a		// RW annunciator 1 off
const CLRAN2		= $c05d		// RW annunciator 2 on
const CLRAN3		= $c05f		// RW annunciator 3 on
const TAPEIN		= $c060		// R cassete tape input
const PADDL0		= $c064		// R analog input 0
const PTRIG			= $c070		// RW analog input reset
const LANGCLR		= $c082		// Disable "Language card" RAM
const LANGSET		= $c083		// Enable "Language card" RAM (requires two writes)
const CLRROM		= $cfff		// disable slot C8 ROM

const TOP_OF_STACK	= $feff		// Put the stack in the "Language card" RAM

const RSTVECTOR		= $fffc  	// Apple ][ 6502 reset vector
const PWREDUP		= $03f4  	// Apple ][ stores #$A5 to make RST a soft reboot

global TXTPTR 		= @$FE.a16	// $FE-$FF is the address of the current line of text
global TXTROW 		= @$3FF		// $3FF is the current row on the text screen
global TXTPOS 		= @$3FE		// $3FE is the current position (column) in the text screen
global TXTPAGE 		= @$3FD		// $3FD is #0 for text page 1 or #1 for text page 2
global TXTBUFFER 	= @$200		// $200-$27F holds the line of text being typed
global TXTBUFFER2 	= @$280		// $280-$2FF holds the previous line of text typed

global R0			= @$00
global R1			= @$01
global R2			= @$02
global R3			= @$03
global R4			= @$04
global R5			= @$05
global R6			= @$06
global R7			= @$07
global R8			= @$08
global R9			= @$09
global R10			= @$0A
global R11			= @$0B
global R12			= @$0C
global R13			= @$0D
global R14			= @$0E
global R15			= @$0F

global ARG0			= @$20
global ARG1			= @$21
global ARG2			= @$22
global ARGW0		= @$20.w
global ARGW1		= @$22.w
global ARGT0		= @$20.t
global ARGT1		= @$23.wt

const MAX_COMMANDS	= 11		// The length-1 of the CommandList


/*
 *  The code begins with a JMPs to the OS functions
 *  followed by a table of addresses for JSR ($aaaa) indirect calls
 */
sub Start @$FF0000 {
	jmp Reset
}

/*
 *  RST vector points here
 */
sub Reset @$FF0200 {
	cld
	sta LANGSET					; turn on ][+ "upper" 16K (write twice)
	sta LANGSET
	r16							; set the stack to be 16-bit wide
	sws
	ldx.w #TOP_OF_STACK			; initialize the stack to start at $FEFF
	txs.w
	
	lda TXTSET					; Start in TEXT mode
	lda TXTPAGE1				;  Page 1
	lda SETAN0					; AN0 = TTL hi
	lda SETAN1					; AN1 = TTL hi
	lda CLRAN2					; AN2 = TTL lo
	lda CLRAN3					; AN3 = TTL lo
	lda CLRROM					; turn off extension ROM
	bit KBDSTRB					; clear keyboard
	
	lda #2
	sta @TXTROW					; Start at TEXT row 2
	stz @TXTPOS					; Start at TEXT position 0
	
	ldx #0
	lda #1
	sta @TXTPAGE				; TEXT page 2
	jsr ClearScreen				; clear the screen (x = row 0; @TXTPAGE = 1)
	ldx #0
	stz @TXTPAGE				; Start in TEXT page 1
	jsr ClearScreen				; clear the screen (x = row 0; @TXTPAGE = 0)

	jsr AppleII4				; draw the header
	; drop through to EchoKeys
}

/*
 *  Echo the keys as they are typed and store in @TXTBUFFER
 */
sub EchoKeys {
	jsr ClearInputBuffers
	LOOP {
		jsr ScreenBase					; Set the @TEXTPTR based on @TXTROW
		lda @TXTPOS
		IF == {
			lda #':'H					; Draw the prompt
			jsr PrintChar
			jsr PrintCursor				; Draw the cursor
		}
		LOOP {
			bit KBD 					; check keyboard for next key
			IF - {
				BREAK
			}
		}
		lda KBD 						; get the key code from the keyboard and ack the read
		bit KBDSTRB
		IF == $8D {						; 13 = CR ($80 | $0D in high ASCII)
			lda #' 'H					; delete the cursor by drawing a space
			sta (@TXTPTR),y
			jsr NextLine
			jsr CurrentToPrevInputBuffer
			jsr CommandLine
			jsr ClearCurrentInputBuffer
			CONTINUE
		}
		IF == $88 {						; 8 = BS ($80 | $08 in high ASCII)
			if > 1 {
				jsr ClearCursor			; Erase the cursor
				lda #' 'H				; Erase the current character
				ldy @TXTPOS
				dey
				sta (@TXTPTR),y
				dey						; Delete the last character in the text buffer
				lda #0
				sta @TXTBUFFER,y
				dec @TXTPOS				; Decrement the text position
				jsr PrintCursor			; Draw the cursor
			}
			CONTINUE
		}
		IF == $95 {						; 21 = Right Arrow ($80 | $15 in high ASCII)
			if > 1 {
				jsr CompleteCommand
			}
			CONTINUE
		}
		IF == $8B {						; 11 = Up Arrow ($80 | $0B in high ASCII)
			jsr PrevToCurrentInputBuffer
			jsr InputBufferToTextScreen
			jsr PrintCursor			; Draw the cursor
			CONTINUE
		}
		IF == $9B {						; 27 = ESC ($80 | $1B in high ASCII)
			ldx @TXTROW
			jsr ClearRow
			jsr ClearCurrentInputBuffer
			lda #0
			sta @TXTPOS					; reset to position 0
			CONTINUE
		}
		IF > $9F {						; >31 = Not a control character ($80 | $1F in high ASCII)
			ldy @TXTPOS
			jsr PrintChar
			cpy #40 					; ignore if >= column 40
			IF < {
				and #$7F				; store (low) ASCII in TEXT buffer
				dey 					; Y-1 as TEXT position starts at 1, making space for the prompt
				sta @TXTBUFFER,y
				jsr PrintCursor
			}
		}
	}
}


/*
 *  Lookup and execute the typed command
 */
sub CommandLine {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6

	lda #@TXTBUFFER						; ARGT0 <- TEXT buffer
	sta.t @ARGT0
	FOR @I = 0 TO MAX_COMMANDS {
		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t @ARGT1
		jsr CompareText
		IF - {
			ldx @I6
	  		lda.t CommandList+3,X		; CommandList[X].func
	  		sta.t @ARGT1
			jsr.a24 (@ARGT1)
			RETURN
		}
	}
	RETURN
}

/*
 *  Try and complete the command
 */
sub CompleteCommand {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6

	lda #@TXTBUFFER						; ARGT0 <- TEXT buffer
	sta.t @ARGT0
	FOR @I = 0 TO MAX_COMMANDS {
		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t @ARGT1
		jsr CompareStartOfText
		IF - {
			ldx @I6
	  		lda.t CommandList,X			; ARGT0 <- CommandList[X].string
	  		sta.t @ARGT0
			lda #@TXTBUFFER				; ARGT1 <- TEXT buffer
			sta.t @ARGT1
			jsr CopyString
			lda.w @TXTPTR				; ARGT1 <- Current line on TEXT screen
			inc.w						;  +1 for the cursor
			sta.t @ARGT1
			jsr CopyStringHigh
			iny
			sty @TXTPOS					; CopyString leaves the length of the string in Y
			jsr PrintCursor
			RETURN
		}
	}

	RETURN
}

#include "2four/util.pom"
#include "2four/commands.pom"
#include "2four/disk4.pom"
#include "2four/data.pom"

/*
 *  The 6502 vectors
 */
data Vectors @$FFFFF7 u24 {
	$000000 	; NMI
	$FF0000 	; RESET
	$000000 	; IRQ
}
